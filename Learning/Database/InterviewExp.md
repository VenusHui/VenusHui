# 数据库

> 2023 春季招聘 / 2024 暑期实习
>
> Reference: [数据库知识手册](https://leetcode.cn/leetbook/detail/database-handbook/)

[TOC] 

## 1. 数据库基础概念

### 1.1 什么是数据库

- 关系型数据库
  - 建立在关系模型基础上，由多张能够相互连接的表组成的数据库
  - 优点
    - 使用表结构，格式一致易于维护
  - 缺点
    - 读写性能较差
    - 关系模型会造成空间浪费
    - 固定的表结构，不够灵活
- 非关系型数据库
  - 数据以对象的形式存储在数据库中，对象之间的关系通过每个对象自身的属性来决定
  - 优点
    - 存储数据的格式灵活
    - 可以轻松进行海量数据的维护和处理
    - 具有可扩展、高并发、高稳定性、成本低等优势
    - 实现数据的分布式处理
  - 缺点
    - 不支持 `SQL, Structured Query Language`  
    - 无事务处理，无法保证数据的完整性和安全性

### 1.2 数据库范式

- 第一范式

  每个列都不可以再拆分，强调的是列的原子性，第一范式要求数据库中的表都是二维表

- 第二范式

  在第一范式的基础上，一个表必须有一个主键，非主键列完全依赖于主键，而不能依赖于主键的一部分

- 第三范式

  在第二范式的基础上，非主键列只直接依赖于主键，不依赖于其他非主键

### 1.3 触发器

触发器 `trigger` 是与表相关的数据库对象

## 2. 事务

### 2.1 事务的特性

#### `Automicity` ：原子性

整个数据库事务是不可分割的工作单位

实现原子性的关键，是当事务回滚时能够撤销所有已经执行的 SQL 语句，InnoDB 实现原子性依据 `undo log` 

`undo log` 属于逻辑日志，记录 SQL 执行的相关信息，当发生回滚时，InnoDB 根据 `undo log` 做与之前相反的工作，如 `insert` 对应 `delete` 	

#### `Consistency` ：一致性

在事务开始前和事务结束后，数据库的完整性约束没有遭到破坏

- 实现一致性即实现原子性、持久性和隔离性
- 数据库本身保障
- 应用层面保障

#### `Isolation` ：隔离性

要求每个读写事务的对象与其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见

##### 锁机制保证隔离性

一个事务写操作对另一个事务写操作的影响

按照粒度，锁可以分为表锁、行锁和其他位于二者之间的锁

InnoDB 同时支持表锁和行锁、且处于性能考虑，绝大多数情况下使用的都是行锁

##### MVCC 保证隔离性

一个事务写操作对于另一个事务读操作的影响

InnoDB 事务的默认隔离级别是 `RR, Repeatable Read` ，解决了脏读、不可重复读、幻读等问题，使用的是 `MVCC, Multi-Version Concurrency Control` 多版本并发控制协议，由于其读不加锁的特点，读写不冲突，并发性能好

#### `Durability` ：持久性

事务一旦提交，其结果就是永久性的

InnoDB 具有缓存 `Buffer Pool` ，其中包含了磁盘中部分数据页的映射。从数据库读取数据时会首先从缓存中读取，若没有则从磁盘读取后将该数据页加入到缓存中；向数据库写入数据时会首先写入缓存，缓存中的数据会定期刷新到磁盘中，这个刷新过程称为 **刷脏** 

若 MySQL 突然宕机，而缓存中的数据还未刷新到磁盘则会导致数据的丢失，此时 `redo log` 被用来解决这个问题。当数据修改时，除了修改缓存中的数据外，还会在 `redo log` 中记录这次操作，当事务提交时，会调用 `fsync` 接口对 `redo log` 进行刷盘，这样在 MySQL 宕机重启后可以读取 `redo log` 中的数据对数据库进行恢复。`redo log` 采用的是 `WAL Write-Ahead Logging` 预写式日志，所有修改先写入日志，再更新到缓存

### 2.2 事务的分类

- 扁平事务：所有操作都处于同一层次，由 `BEGIN WORK` 开始，由 `COMMIT WORK` 或 `ROLLBACK WORK` 结束，处于之间的操作是原子的，要么都执行，要么都回滚
- 带有保存点的扁平事务：除支持扁平事务的操作外，允许事务在执行过程中会滚到同一事务的较早状态，保存点 `save point` 用来通知系统应该记住事务当前的状态，以便发生错误时事务能够回到该状态
- 链事务：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式的传给下一个要开始的事务，此时提交事务和开始下一个事务操作将被合并为一个原子操作
- 嵌套事务：有一个顶层事务 `top-level transaction` 控制各个层次的事务，顶层事务之下嵌套的事务成为子事务 `subtransaction` 
- 分布式事务：在分布式环境下运行的扁平事务

### 2.3 事务的隔离级别

- `Read Uncommitted` ：读未提交
- `Read Committed` ：读已提交，解决脏读
- `Repeatable Read` ：可重复读，解决不可重复读，InnoDB 通过 `Next-Key Lock` 锁算法避免了幻读的产生
- `Serializable` ：串行化，解决幻读

并发情况下读操作可能产生的问题：

- 脏读：当前事务可以读到其他事务未提交的数据
- 不可重复读：在事务中先后两次读取同一个数据，两次读取的结果不一样
- 幻读：在事务中按照某个条件先后两次查询数据库，两次查询结果的条数不同

## 3. 数据库优化

### 3.1 数据库结构优化

- 将字段很多的表分解成多个表
- 增加中间表
- 增加冗余字段

### 3.2 分库分表

#### 垂直切分

- 优点
  - 行数据变小，查询时减少读取的 `Block` 数
  - 减少 I/O 次数
  - 简化表结构、易于维护
- 缺点
  - 主键冗余，需要管理冗余列
  - 会引起 `JOIN` 操作
  - 加大事务的管理难度

#### 水平切分

- 优点
  - 支持非常大的数据量存储
  - 应用端改造少

## 4. SQL

### 4.1 分页

```sql
-- 返回所有结果中的前 N 行记录
SELECT <attribute> FROM <table> LIMIT N
-- 在所有查询结果中，从第 N 行开始返回 M 行记录
SELECT <attribute> FROM <table> LIMIT N, M
```

### 4.2 聚合函数

### 4.3 表的连接

### 4.4 SQL 注入

## 5. 索引

### 5.1 索引介绍

索引是一个单独的、存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针

目的：快速找出在某个或多个列中有一特定值的行

索引的存储类型

- BTREE：MyISAM、InnoDB 存储引擎只支持 BTREE 索引
- HASH

索引的优点

- 通过创建唯一索引，保证数据库表中每一行数据的唯一性
- 假胯数据的查询速度
- 在实现数据的参考完整性方面，可以加速表与表之间的连接
- 在使用分组和排序子句进行数据查询时，可以减少查询中分组和排序的时间

索引的缺点

- 创建索引和维护索引要耗费额外的时间
- 索引占据磁盘空间，若有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸

### 5.2 索引类型

#### 普通索引和唯一索引

- 普通索引：MySQL 中的基本索引类型
- 唯一索引：要求索引列的值必须唯一，允许有空值
  - 若为组合索引，则列值的组合值必须唯一
  - 主键索引是特殊的唯一索引，不允许有空值

#### 单列索引和组合索引

- 单列索引：一个索引只包含单个列，一个表可以有多个单列索引
- 组合索引：在表的多个字段组合上创建的索引，只有查询条件中使用了这些字段的左边字段使索引才会被使用，使用时遵循最左前缀集合

#### 全文索引

在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值

全文索引 `FULLTEXT` 可以在 `CHAR` 、 `VARCHAR` 、 `TEXT` 类型的列上创建

#### 空间索引

空间索引 `SPATIAL` 可以在  `GEOMETRY` 、 `POINT` 、 `LINESTRING` 、 `POLYGON` 空间数据类型上创建

### 5.3 实现原理

B+树
