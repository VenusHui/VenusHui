## 动态规划

### 两个要求

* 最优子结构
  + 大问题的（最优）解可以由小问题的（最优）解推出。
  + 问题的拆解过程中不能无限递归（不能成环绕圈）。

* 无后效性
  + 未来与过去无关，即一旦得到了一个小问题的解，如何得到它的解的过程不影响大问题的求解

### 两个元素

* 状态：一个字问题，即指求解过程进行到了哪一步

* 转移：从一个状态推导出另一个状态的过程

## 背包问题

### 01背包问题

- 枚举： 用一个二进制串枚举每一个物品取还是不取
  - 剪枝：考虑了前i个物体取或不取，若有两组方案总体积相等，嘛么只需要保留总收益大的那一组
  - nm：
  - 2m：滚动数组，优化空间复杂度
  - m：
```cpp
for(int i = 1; i <= n; i++)
    for (int j = m; j >= v[i]; j--)
        f[j] = max(f[j], f[j - v[i]] + w[i]);
```

#### 完全背包

- 转移的时候可以从同层转移
```cpp
f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i]);
```

### 区间动态规划

- 记忆化搜索：在递归的过程中存储重复计算的结果