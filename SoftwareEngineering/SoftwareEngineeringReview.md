# 软件工程复习

> Copyright：VenusHui
>
> Reference：《软件工程-实践者的研究方法.8th》、PowerPoints from 杜庆峰

## 1 软件的本质

### 软件定义

- 指令的集合、数据结构、软件描述信息
- 不会磨损
- 变更：用户需求变化；用户对需求的理解 vs 开发者对需求的理解

### 云计算

- 基础设施层：IaaS `Infrastructure as a Service` 
- 平台层 / 中间件层：PaaS `Platform as a Service` 
  - 资源监测
  - 预警
  - 优化决策
- 应用层 / 软件服务层： SaaS `Software as a Service` 

## 2 软件工程

### 软件工程学科

- 一种层次化的技术
  - 根基：质量关注点 `quality focus` ，任何工程方法必须构建在质量承诺的基础之上
  - 基础：过程层 `process` ，软件过程构成了软件项目管理控制的基础
  - 方法：技术上的解决方案，包括沟通、需求分析、设计建模、程序构造、测试和技术支持
  - 工具：为过程和方法提供自动化或半自动化的支持

### 软件过程

- 过程框架
  - **沟通**
  - **策划**
  - **建模**：需求建模 + 设计建模
  - **构建**
  - **部署**
- 普适性活动：软件工程过程框架活动由很多普适性活动来补充实现，主要关注项目管理、跟踪和控制
- 过程的适应性调整：软件工程过程是灵活可适应的

### 软件工程实践

- 实践的精髓
  - 理解问题
    - 分析模型：主要矛盾和可能的解决方案
  - 策划解决方案
  - 实施计划
  - 检查结果
    - 质量的内涵：有多种属性，其中可靠性 / 准确性为首要目标
- 通用原则
  - 存在价值
  - 保持简洁
  - 保持愿景
  - 关注使用者
  - 面向未来
  - 提前计划复用
  - 认真思考

### 软件开发神话

- 管理神话
- 客户神话
- 从业者神话

## 3 软件过程结构

### 通用过程模型

- 技术工作层次：活动 > 动作 > 任务
  - 每个框架活动由一系列软件工程动作构成；每个软件工程动作由任务集来定义
    - 任务集明确了：工作任务、工作产品、质量保证点、项目里程碑
  - 每一个任务都隶属于某一框架或者模型
- 过程流：沟通、策划、建模、构建、部署的顺序
  - **线性过程流** `linear process flow` ：顾名思义
  - **迭代过程流** `iterative process flow` 
  - **演化过程流** `evolutionary process flow` ：整个过程的循环迭代
  - **并行过程流** `parallel process flow` ：部分过程并行执行

### 定义框架活动

五种框架活动：沟通、策划、建模、构建、部署，每个活动都可以细化为一系列动作

### 明确任务集

### 过程模式

> Process Pattern，描述了软件工程工作中遇到的过程相关的问题，明确了问题环境并给出了针对该问题的一种或几种可证明的解决方案

过程模式的描述模板

- 模式名称
- 驱动力
- 类型
  - **步骤模式** `stage pattern` ：例如：建立沟通。定义了与过程的框架活动相关的问题，步骤模式可能包含一系列任务模式
  - **任务模式** `task pattern` ：例如：需求收集。定义了与软件工程动作或是工作任务相关、关系软件工程实践成败的问题
  - **阶段模式** `phrase pattern` ：例如：螺旋模型、原型开发。定义在过程中发生的框架活动序列
- 问题
- 解决方案
- 结果
- 相关模式
- 已知应用和实例

## 4 过程模型

- 重要性：软件过程提高了软件工程活动的 **稳定性、可控性和有组织性** ，减少开发新软件产品时出现的混乱

### 惯用过程模型

> 定义了一组规定的过程元素和一个可预测的过程工作流，有时称为“传统”过程模型

- 瀑布模型 `waterfall model` 
  - 又称经典生命周期 `classic life cycle` ，提出了一个系统的、顺序的软件开发方法
  - 条件：可以清楚的理解问题的需求
    - 需要对一个已经存在的系统进行明确定义的自适应调整或事增强时
    - 少数很新的开发工作上，需求必须是准确定义和相对稳定的
  - V 模型 `V model` ，瀑布模型的变体
    - 阐明了验证和确认动作如何与早起工程动作互相关联
  - 存在的问题
    - 实际项目很少遵守瀑布模型提出的顺序
    - 客户通常难以清楚地描述所有的需求
    - 客户只有在项目接近尾声的时候才能得到可执行的程序
- 增量过程模型
  - 交付一系列称为增量的版本，随着每个版本的交付，逐步为用户提供更多的功能
  - 综合了现行过程流和并行过程流的特征，在每个阶段都应用线性序列，每个线性序列生产出软件的可交付增量，多个线性序列可以流水线并行进行
  - 第一个增量往往是 **核心产品** 
- 演化过程模型
  - 是迭代的过程模型，每个迭代产生软件的一个更完整的版本
  - **原型开发** 
    - 适用条件：在以下两个条件下采用原型开发范型 `prototyping paradigm` 
      - 客户定义了软件的一些基本任务，但没有详细定义功能和特性需求
      - 开发人员对算法的效率、操作系统的适用性、人机交互的形式等情况并没有把握
      - 总结：需求模糊的时候，有一个合理的要求但对细节没有思路，可以先开发一个原型
    - 过程：下面五个过程循环迭代
      - 沟通
      - 快速策划
      - 快速设计：集中在最终用户能看到的方面
      - 构建原型
      - 部署交付并获取反馈
    - 存在的问题
      - 利益相关者看到了软件的工作版本，却未察觉到软件时随意搭成的，也未察觉到位了尽快完成软件，开发者并没有考虑整体软件质量和长期可维护性
      - 位了是一个原型快速运行起来，往往在实现过程中采用折衷的手段
  - **螺旋模型** 
    - 是一种演进式软件过程模型，结合了原型的迭代性质和瀑布模型的可控性和系统性特点，具有快速开发越来越完善的软件版本的潜力，可以运用在应用系统开发的整个生命周期，从概念开发到维护
    - 特点
      - 采用循环的方式逐步加深系统定义和实现的深度，同时降低风险
      - 确定一系列里程碑作为支撑点，确保利益相关者认可是可行的且可令各方满意的系统解决方案
    - 将软件开发为一系列演进版本，早起可能为理论模型或原型，后期会产生一系列逐渐完善的系统版本
    - 在每次演进的时候都要考虑风险，所以螺旋模型是一种风险驱动型的 **过程模型生成器** 
    - 螺旋模型吧原型作为降低风险的机制，开发人员可以在产品演进的任何阶段使用原型方法
    - 存在的问题
      - 很难以合同的形式使客户相信演进的方法是成功的
      - 依赖大量的风险评估专家来保证成功

## 5 敏捷开发

- 敏捷软件工程代表了传统软件工程的合理替代方案。 它已被证明可以快速交付成功的系统
- 鼓励客户满意度和软件的早期增量交付，提倡小型、积极性高的项目团队；非正式方法；最少的软件工程工作产品；和整体开发的简单性
- 软件开发者和其他利益相关者在同一个敏捷团队中工作，敏捷团队促进所有服务人员之间的沟通和协作，交流可以存在于软件开发的任何阶段

### 什么是敏捷

- 普遍存在的变更是敏捷的基本动力，鼓励能够使沟通更便利的团队结构和写作态度

### 敏捷及变更成本

- 敏捷是动态的，针对特定内容的，主动应对变更及面向成长的
- 一个设计良好的敏捷过程可以有效拉平变更曲线，当增量交付与其他敏捷实践相结合时，例如单元测试和结对编程，引起变更的费用会衰减
  - 在增量内部的变更能得到较好的控制

### 极限编程

> XP, eXtreme Programming，敏捷开发中使用最广泛的一种方法

- 极限编程过程
  - 策划
    - 倾听：需求收集，用户故事，描述将要开发的软件所需哟啊的输出、特性、功能
    - 客户评估故事优先级，并给出一开发周期为度量单位的成本；新故事可以在任何时刻书写
    - 将故事分组，置于下一个发行版本的软件增量中，进行承诺，并对待开发的故事进行排序
    - 第一个发行版本交付后，XP 团队计算项目的速度，即第一个发行版本实现的故事个数，若发生过份承诺则需要调整发行内容或更改交付日期
  - 设计
    - 严格遵循 KIS `Keep It Simple` ：使用简单的设计，而不是复杂的表述
    - 为故事提供提供恰好可实现的知道，而不鼓励额外的功能性设计
    - 鼓励使用 CRC `Class Responsibility Cooperator` 卡作为面向对象环境中考虑的有效机制
    - 如果某个故事设计出现困难，XP 推荐这部分执行原型，即 **spike** 解决方案，旨在在真正实现开始时就降低风险，对可能存在的设计问题的故事确认其最初的估计
    - 鼓励 **重构** ：即是构建技术，又是设计技术，在不改变外部功能或行为的情况下改进设计或源代码的内部结构
  - 编码
    - 开发一些列用于检测本次软件增量的包括所有故事的单元测试，建立单元测试之后，开发者就能够更加集中精力于必须实现的内容以通过测试
    - 结对编程：XP 建议两个人面对共同一台计算机为同一个故事开发代码
      - 实时解决问题：两个人 > 一个人
      - 实时质量保证：代码写出后及时复审
    - 集成团队将代码与其他人的工作集成起来
  - 测试
    - 建立的单元测试应当使用一个可以自动实施的框架，便于每当代码修改之后的即时回归测试策略
    - XP 验收测试，也称客户测试，是由用户故事驱动的

### Scrum

- 敏捷原则
  - 个体与交互 > 过程与工具
  - 可以工作的软件 > 面面俱到的文档
  - 客户协作 > 合同谈判
  - 响应变化 > 遵循计划
- Scrum 是一个轻量级的软件开发过程模型，是一个增量的、迭代的开发过程
- 在 Scrum 敏捷开发框架下，开发周期包括若干小的迭代周期 `sprint` ，长度建议 2 ～ 4周
- 使用 `Backlog` 管理工作产品或项目的需求
  - `Backlog` 是一个按照商业价值排序的需求列表，列表条目为用户故事
  - 每个 `sprint` 中从 `Backlog` 挑选最有价值的需求进行开发
  - 每个迭代结束时，Scrum 团队将交付潜在可交付的产品增量
- Scrum 角色
  - 产品负责人 `Product Owner` 
    - 确定产品功能
    - 决定发布日期和发布内容
    - 为产品的 `ROI, Return On Investment` 负责
    - 根据市场价值确定功能优先级
    - 每个 `Sprint` 前调整功能及其优先级
    - 接受或拒绝开发团队的工作成果
  - Scrum Master
    - 将 Team Leader 和 Product Owner 紧密的工作在一起
    - 保证团队资源完全可被利用并且高产出
    - 保证各个角色及职责良好协作
    - 解决团队开发中的障碍
    - 作为团队和外部的接口，屏蔽外界对团队成员的干扰
    - 保证开发过程按计划进行，组织会议
  - 团队 `Team` 
    - 负责产品开发
    - 团队是跨职能的，包括开发、测试、用户界面设计师等
    - 团队成员需要全职
    - 高度的自组织能力
    - 向 Product Owner 演示产品功能
    - 团队构成在 `sprint` 内不允许变化
    - 团队整体向产品开发负责
- Scrum Work Products
  - `Backlog` ：有优先级的故事列表
  - `Sprint Backlog` ：当前 `sprint` 要完成的故事列表，并估算工时
  - 发布燃尽图 `burn down chart` ：在项目完成之前对需要完成的工作的可视化表示
- Scrum 过程
  - Scrum 计划会议
  - Scrum 每日站会
  - Scrum 评审会议
  - Scrum 回顾会议

## 7 理解需求

### 需求工程

> RE, Requirement Engineering

- 致力于不断理解需求的大量任务和技术
- 是一个软件工程动作，开始于沟通并持续到建模活动
- 需求工程为设计和构建奠定了坚实的基础
- 需求工程的任务（某些任务会并行发生）
  - 起始
    - 存在的问题
    - 谁需要解决方案
    - 所期望解决方案的性质
    - 与项目利益相关者和开发人员之间达成初步交流合作的效果
  - 获取：产出 use case
    - 建立商业目标
    - 建立优先机制，建立潜在架构的合理性设计
  - 细化
    - 将在起始和获取阶段获得的信息进行提炼和扩展
    - 开发一个精确的需求模型，用以说明软件的功能、特征和信息的各个方面
    - 由一系列的用户场景建模和求精任务驱动：解析每个用户场景以便分析提取类
  - 协商
    - 通过协商调解冲突：采用迭代的方法给需求排序，按照优先级讨论冲突
  - 规格说明
    - 规格说明的形式和规格随着待开发软件的规模和复杂度不同而变化：需求规约和需求分析规约
  - 确认
    - 对需求工程的工作产品进行质量评估
    - 需求确认中的重要问题：一致性，使用分析模型可以保证需求说明的一致性
    - 正式的技术评审是最主要的需求确认机制
  - 管理
    - 需求变更贯穿于系统的整个生命周期
    - 用于帮助项目组在项目进展中标识、控制和跟踪需求变更的活动

### 建立根基

> 启动需求工程所必须的步骤

- 确认利益相关者
  - 直接或间接地从正在开发的系统中获益的人
- 识别多重观点
  - 从多个角度进行系统需求调研
- 协同合作
- 首次提问
  - 第一组问题：“与环境无关”，集中于客户和其他利益相关者的整体目标和收益
  - 下一组问题：有助于软件开发者更好地理解问题，并允许客户表达其对解决方案的看法
  - 最后一组问题：关注沟通活动本身的效率

### 获取需求

> 将问题求解、细化、协商和规格说明等元素结合在一起

- 协作收集需求
  - 目标：标识问题，提出假设解决方案的相关元素，协商不同方法以确定一套解决需求问题的初步方案
  - 基本原则
    - 实际或虚拟的会议由软件工程师和其他利益相关者共同举办和参与
    - 制定筹备和参与会议的规则
    - 你定一个会议议程，涵盖所有要点，鼓励思维自由交流
    - 由一个主持人控制会议
    - 采用“方案论证手段”
- 质量功能部署 `QFD, Quality Function Deployment` 
  - 将客户要求转化成软件技术需求的技术，以最大限度地满足客户的方式来定义需求
  - 常规需求
  - 期望需求
  - 兴奋需求
- 使用场景
  - 场景可以识别对将要构建系统的使用线索，帮助软件团队弄清不同类型的最终用户如何使用系统功能和特性
  - 场景通常被称为用例
- 获取工作产品
  - 要求和可行性陈述
  - 系统或产品范围的界限说明
  - 参与需求获取的客户、用户和其他相关利益者的名单
  - 系统技术环境的说明
  - 需求列表以及每个需求适用的领域限制，并按照功能加以组织
  - 一系列使用场景，有助于深入了解系统或产品在不同环境下的使用
  - 任何能够更好地定义需求的原型
- 敏捷需求获取
  - 在敏捷过程模型中，用户故事是从客户中获取并记录需求的方式
- 面向服务的方法
  - 面向服务开发的需求获取关注由应用系统所定义的服务
  - 细化了由应用场景所衍生出的服务，每一个触点都代表用户和系统的一次交互，从而获得所需的服务

### 开发用例

- 用例讲述了程式化的故事：最终用户如何在特定环境下和系统交互
- 用例是从参与者的角度定义的，参与者是任何与系统或产品通信的事物，且对系统本身而言是外部的
- 需求获取是一个逐步演化的活动，第一次迭代无法确认所有的参与者，但有可能识别主要参与者

## 8 需求建模：基于场景的方法

### 需求分析

- 产生软件工作特征的规格说明，指明软件和其他系统元素的借口，规定软件必须满足的约束
- 需求建模动作的结果
  - **场景模型**：观点的需求
  - **面向类的模型**：表示面向对象类的模型，通过类的协作获得系统需求
  - **基于行为和模式的模型**：描述如何将软件行为看作外部事件后续的模型
  - **数据模型**：描述问题信息域的模型
  - **面向流的模型**：表示系统的功能元素并且描述当功能元素在系统中运行时怎样进行数据变换
- 一旦软件完成后，需求模型和需求规格说明书将称为评估软件质量的手段
- 总体目标和原理
  - 关注做什么而不是怎么做
  - 目标
    - 描述客户需要什么
    - 为软件设计奠定基础
    - 定义软件在完成后可以被确认的一组需求
  - 需求模型的所有元素都可以直接跟踪到设计模型
- 分析的经验原则
  - 模型应关注问题域或业务域内可见的需求，抽象的级别应该高一点
  - 需求模型的每个元素都应能增加对软件需求的整体理解，并提供对信息域、功能和系统行为的深入理解
  - 关于基础结构和其他非功能的模型应推迟到设计阶段再考虑
  - 最小化整个系统内的关联
  - 确认需求模型为所有利益相关者都带来价值
  - 尽可能保持模型简洁
- 域分析
  - 查找或创建那些广泛应用的类或分析模式，使其能够复用
  - 不关注特定的系统应用，而是关注应用所属的领域，目的在于识别那些可以用于解决域内所有应用系统的共同问题
  - 可以看作软件过程的一个普适性活动
- 需求建模的方法
  - 结构化分析：将数据作为独立实体加以转换
  - 面向对象的分析：关注类的定义和影响客户需求的类之间的协作方式

### 基于场景建模

- 创建初始用例
  - 起始和获取提供了开始编写初始用例所需要的信息
  - 列出特定参与者执行的功能或活动
- 细化初始用例
  - 次场景：属于原始用例的一部分，但表现了可供选择的行为
  - 用例异常
- 编写正式用例

### 活动图和泳道图

## 10 需求建模：基于类的方法

### 识别分析类

- 带有下划线的每个名词或名词词组可以作为确定为类

### 描述属性

### 定义操作

### 类 - 职责 - 协作者建模

> CRC, Class Responsibility Collaborator

- 提供了一个简单方法，可以识别和组织与系统或产品需求相关的类
- 类
  - 实体类：也称模型或业务类，从问题说明中直接提取出来
  - 边界类：创建用户可见的和使用软件时交互的接口
  - 控制类
    - 管理实体类的创建或更新
    - 边界类从实体对象获取信息后的实例化
    - 对象集合间的复杂通信
    - 对象间或用户和应用系统间交换数据的确认
- 职责
  - `Distribute` ：智能系统应分布在所有类中以求最大程度的满足问题的需求
  - `General` ：每个职责的说明应尽可能具有普遍性
  - `Encapsulation` ：信息和与之相关的行为应放在同一个类中
  - `Localised` ：某个事物的信息应该局限在一个类中而不是多个类中
  - `Shared` ：适合时，职责应由相关类共享
- 协作
  -  `Inner` ：使用自己的方法来操纵自己的属性，从而履行特定的责任
  -  `Collaborate` ：与其他类合作，给其他类用属性或使用其他类属性
- CRC 模型的评审
  - `Seprertion` ：审核的所有人都发到CRC卡，有合作关系的卡分开，确保一个人手上的牌之间都没有协作关系
  - `Category` ：所有的use-case scenario（以及相应的用例图）需要被分类
  - `Leader` ：审查的领导人读取一个用例，进而引入一个已命名的对象。领导人将令牌token传递给有相应的类索引的人
  - `Describe` ：当token传递时，要求卡片的持有者描述卡上注明的责任。审核组确定是否有一个（或更多）的责任满足用例要求
  - `Modify` ：如果在索引卡上指出的责任和协作无法适应用例，则修改卡片。这可能包括新类（以及相应的CRC索引卡）的定义或在现有卡上的新或修订的责任或协作的规范。

### 关联和依赖

### 分析包

- 分析建模的一部分重要工作就是分类，将分析模型的各种元素分类，分组打包后称为分析包

## 11 需求建模：行为和模式

### 生成行为模式

- 评估所有用例，以保证完全理解系统内的交互顺序
- 是被驱动交互顺序的事件，并理解这些事件如何与特定的对象关联
- 为每个用例生成序列
- 创建系统状态图
- 评审行为模型以验证准确性和一致性
